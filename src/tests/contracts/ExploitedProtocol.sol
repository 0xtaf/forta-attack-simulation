// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import './CustomERC20.sol';
import './CustomERC721.sol';
import './CustomERC1155.sol';

contract ExploitedProtocol {
    address[] _erc20Contracts;
    address[] _erc721Contracts;
    address[] _erc1155Contacts;
    uint256[] _erc20ContractsSupply;
    uint256[] _erc721TokensAmount;
    uint256[][] _erc1155TokensSupply;

    constructor(
        address[] memory erc20Contracts,
        uint256[] memory erc20ContractsSupply,
        address[] memory erc721Contracts,
        uint256[] memory erc721TokensAmount,
        address[] memory erc1155Contracts,
        uint256[][] memory erc1155TokensSupply
    ) public payable {
        _erc20Contracts = erc20Contracts;
        _erc721Contracts = erc721Contracts;
        _erc1155Contacts = erc1155Contracts;
        _erc20ContractsSupply = erc20ContractsSupply;
        _erc721TokensAmount = erc721TokensAmount;
        _erc1155TokensSupply = erc1155TokensSupply;

        for (uint256 i = 0; i < erc20Contracts.length; i++) {
            CustomERC20 token = CustomERC20(erc20Contracts[i]);
            token.mint(address(this), erc20ContractsSupply[i]);
        }

        for (uint256 i = 0; i < erc721Contracts.length; i++) {
            CustomERC721 token = CustomERC721(erc721Contracts[i]);
            token.mint(address(this), erc721TokensAmount[i]);
        }

        for (uint256 i = 0; i < erc1155Contracts.length; i++) {
            CustomERC1155 token = CustomERC1155(erc1155Contracts[i]);
            token.mint(address(this), erc1155TokensSupply[i]);
        }
    }

    function useExploit(address attacker) public {
        payable(attacker).send(address(this).balance);

        for (uint256 i = 0; i < _erc20Contracts.length; i++) {
            CustomERC20 token = CustomERC20(_erc20Contracts[i]);
            uint256 balance = token.balanceOf(address(this));
            token.transfer(
                attacker,
                balance
            );
        }

        for (uint256 i = 0; i < _erc721Contracts.length; i++) {
            CustomERC721 token = CustomERC721(_erc721Contracts[i]);
            token.setApprovalForAll(attacker, true);
            for (uint256 tokenId = 0; tokenId < _erc721TokensAmount[i]; tokenId++) {
                token.transferFrom(address(this), attacker, tokenId);
            }
        }

        for (uint256 i = 0; i < _erc1155Contacts.length; i++) {
            CustomERC1155 token = CustomERC1155(_erc1155Contacts[i]);
            token.setApprovalForAll(attacker, true);
            uint256[] memory tokensSupply = _erc1155TokensSupply[i];
            uint256 singleTransferred = tokensSupply.length / 2;
            uint256 batchTransferred = tokensSupply.length - singleTransferred;
            for (uint256 tokenId = 0; tokenId < singleTransferred; tokenId++) {
                token.safeTransferFrom(
                    address(this),
                    attacker,
                    tokenId,
                    tokensSupply[tokenId],
                    ''
                );
            }
            uint256[] memory tokenIds = new uint256[](batchTransferred);
            uint256[] memory tokenValues = new uint256[](batchTransferred);
            for (uint256 i = 0; i < batchTransferred; i++) {
                uint256 tokenId = i + singleTransferred;
                tokenIds[i] = tokenId;
                tokenValues[i] = tokensSupply[tokenId];
            }
            token.safeBatchTransferFrom(address(this), attacker, tokenIds, tokenValues, '');
        }
    }
}
